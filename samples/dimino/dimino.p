$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$ A simple implementation of Diminos algorithm for permutation group enumeration
$ input: list S of generators of a group G
$ output: list G of elements of G
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
import "search.p";

fun dimino {
   if ((sizeof args[0]) == 0) return "ERROR: " + S + " too small";

   local S = [-1] + args[0]; $ generators, pad with dummy for [0]
   local t = sizeof S - 1;
   local G = [-1, ()]; $ elements of G, [0] ignored

   local order = 1;
   local g=S[1];
   local i = 0; $ loop iterator

   $ add the first generator
   while (g != ()) {
      order = order + 1;
      $ print "adding " + g;
      G = G + [g];
      g = g * S[1];
   }

   $ induct
   for (i=2; i<=t; i=i+1) {
      found = search (G, S[i]);

      if (!found) { $ the next generator is not redundant
         previous_order = order;

         $ add the coset generated by S[i]
         order = order + 1;
         $ print "adding " + S[i];
         G = G + [S[i]];

         for (j=2; j<=previous_order; j=j+1) {
            order = order + 1;
            $ print "adding " + G[j] * S[i];
            G = G + [G[j] * S[i]];
         }

         $ get coset representatives position
         rep_pos = previous_order + 1;

         while (rep_pos <= order) {
            for (k=1; k<=i; k=k+1) {
               element = G[rep_pos] * S[k];
               found = search (G, element);

               if (!found) {
                  $ add coset
                  order = order + 1;
                  $ print "adding " + element;
                  G = G + [element];
                  for (j=2; j<=previous_order; j=j+1) {
                     order = order + 1;
                     $ print "adding " + G[j] * element;
                     G = G + [G[j] * element];
                  }
               }
            }

            $ get position of next coset representative
            rep_pos = rep_pos + previous_order;
         }

      }
   } $ induction loop

   return G;
}

